> 타입스크립트는 정적 타이핑을 제공합니다.
> 정적 타이핑을 하기 위해 타입스크립트가 제공하는 타입과 관련된 내용을 살펴보면서 타입이란 무엇이고 다른 언어에서 타입은 어떻게 동작하는지 먼저 살펴보고, 타입스크립트에서는 타입을 어떻게 사용할 수 있는지 알아보는 시간입니다.

## 02.1 타입이란

### 자료형으로서의 타입

- 모든 프로그래밍 언어는 변수를 선언하는 것부터 시작합니다.
- 프로그래밍 언어에서 변수란 값을 저장할 수 있는 공간이자 값을 가리키는 상징적인 이름입니다.
- 개발자는 변수를 선언하고 그 변수에 특정한 값인 데이터를 할당하게 됩니다.
  - 특정 메모리에 값을 효율적으로 저장하기 위해서는 먼저 해당 메모리 공간을 차지할 값의 크기를 알아야 합니다.
  - 값의 크기를 명시해준다면 컴퓨터가 값을 참조할때 한 번에 읽을 메모리 크기를 알 수 있어 값을 훼손하지 않고 가져올 수 있습니다.

> ECMAScript 표준을 따르는 자바스크립트는 7가지 데이터 타입(자료형)을 정의하고 있습니다
>
> - undefined
> - null
> - Boolean
> - String
> - Numeric (Number & BinInt)
> - Object
> - Symbol

- 데이터 타입은 여러 종류의 데이터를 식별하는 분류 체계로 컴파일러에 값의 형태를 알려줍니다.
- 메모리에 저장된 값을 테이터 타입으로 설명할 수 있으며 모든 데이터를 해석할 때 데이터 타입 체계가 사용됩니다.

### 집합으로서의 타입

- 프로그래밍에서 타입은 수학의 집합과 유사합니다.
- 타입은 값이 가질 수 있는 유효한 범위의 집합을 이야기합니다.
- 값의 타입이 정의되어있다면 컴파일러 또는 개발자가 이 값으로 어떤 일을 할 수 있고, 어떤 일을 할 수 없는지 사전에 파악할 수 있습니다.
- 타입 시스템은 코드에서 사용되는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지해줍니다.

### 정적 타입과 동적 타입

- 정적 타입 시스템에서는 모든 변수의 타입이 컴파일타임에 결정됩니다.
  - 코드 수준에서 개발자가 타입을 명시해줘야 하는 C, 자바, 타입스크립트 등이 정적 타입 언어에 속합니다.
  - 번거롭게 느껴지기도 하지만 컴파일타임에 타입 에러를 발견할 수 있기 때문에 프로그램의 안정성을 보장할 수 있습니다.
- 동적 타입 시스템에서는 변수 타입이 런타임에서 결정됩니다.
  - 파이썬, 자바스크립트가 대표적인 동적 타입 언어로 개발자는 직접 타입을 정의할 필요가 없습니다.
  - 프로그램을 실행하는 런타임 시점에 타입 에러가 발견되기 때문에 안정성이 떨어집니다.

> ##### 아하모먼트
>
> ##### 컴파일타임과 런타임
>
> 개발자가 작성한 소스코드를 실행하려면 몇 가지 과정을 거쳐야 하는데 시점에 따라 컴파일타임과 런타임으로 구분할 수 있습니다.
> 기계(컴퓨터, 엔진)가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점을 컴파일타임이라고 하며 이후 변환된 파일이 메모리에 적재되어 실행되는 시점을 런타임이라고 부릅니다.

### 강타입과 약타입

- 결론적으로 타입이 결정되는 시점은 다르지만 모든 프로그래밍 언어에는 값의 타입이 존재합니다.
- 자바스크립트처럼 컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것을 암묵적 타입 변환 이라고 힙니다.
- 암묵적 타입 변환 여부에 따라 타입 시스템을 `강타입`과 `약타입`으로 분류할 수 있습니다.
  - 강타입 특징을 가진 언어에서는 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터 에러가 발생합니다.
  - 약타입 특징을 갖는 언어에서 서로 다른 타입을 갖는 값끼리 연산할 때는 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출합니다.
- 암묵적 변환은 개발자가 명시적으로 타입을 변환하지 않아도 다른 데이터 타입끼리 연산을 진행할 수 있는 편리함을 제공하지만, 작성자의 의도와 다르게 동작할 수 있기 때문에 예기치 못한 오류가 발생할 가능성도 높아집니다.
  - 예시로 자바스크립트는 타입이 명백하게 잘못 작성된 코드도 암묵적 타입 변환을 통해 결과를 도출합니다.
- 자바스크립트는 약타입 언어이기 때문에 런타입에서 발생할 수 있는 에러를 예측하고 방지하기 위해 타입 안정성을 확보하는것이 프로그램을 안전하게 만드는데 도움이 됩니다.
- 타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합을 타입 시스템이라고 합니다.
- 타입 시스템은 크게 두가지로 구분할 수 있습니다.
  - 어떤 타입을 사용하는지를 컴파일러에 명시적으로 알려줘야 하는 타입 시스템
  - 자동으로 타입을 추론하는 타입시스템

타입스트립트는 두 가지 타입 시스템에 모두 영향을 받았습니다.

- 즉 개발자는 직접 타입을 명시하거나, 타입스크립트가 타입을 추론하도록 하는 방식중에서 선택할 수 있습니다.

### 컴파일 방식

> 컴파일의 일반적인 의미는 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정을 말합니다.

- 개발자가 고수준의 언어로 소스코드를 작성하면, 컴파일러는 컴퓨터가 해석할 수 있는 바이너리 코드로 변환합니다.
- 언어마다 컴파일 과정과 단계에 조금씩 차이가 있지만 기본적으로 컴파일은 서로 다른 수준 (고수준 - 저수준) 간의 코드 변환을 의미합니다.
- 타입스크립트의 컴파일 결과물은 여전히 사람이 이해할 수 있는 방식인 자바스크립트 파일입니다.
  - 타입스크립트가 탄생한 이유는 사람이 이해하기 쉬운 방식으로 코드를 작성하기 위해서가 아닌 자바스크립트의 컴파일타임에 런타임 에러를 사전에 잡아내기 위한 것입니다.
  - 타입스트립트를 컴파일하면 타입이 모두 제거된 자바스크립트 소스코드만 남게됩니다.

## 02.2 타입스크립트의 타입 시스템

### 타입 애너테이션 방식 (type annotation)

- 타입 애너테이션이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법입니다.
- 타입스크립트에서는 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입을 명시해줍니다.

```ts
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```

- 타입스크립트는 기존 자바스크립트 코드에 점진적으로 타입을 적용할 수 있는 특징을 가지고 있습니다.
- 예시 코드에서 타입 선언부를 제거해도 코드는 정상적으로 동작합니다. 하지만 타입스크립트 타입 시스템이 타입을 추혼하는 과정에서 어려움이 생깁니다.

### 구조적 타이핑

- 타입을 사용하는 여러 프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 갖고 있습니다.
- 타입은 이름으로 구분되며 컴파일타임 이후에도 남아있습니다.
- 이것을 명목적으로 구체화한 타입시스템 이라고 부르기도 합니다.
  - Nominal Reified Type Systems!
- 타입스크립트에서 타입을 구분하는 방식은 조금 특이합니다.
  - 이름으로 타입을 구분하는 명목적인 타입 언어의 특징과 달리 타입스크립트는 구조로 타입을 구분합니다.
  - 이것을 구조적 타이핑이라고 합니다.

### 구조적 서브타이핑

- 앞의 내용에서는 타입스크립트의 타입 시스템을 집합으로 이해할 수 있다로 언급하였습니다.
- 타입스크립트의 타입은 값의 집합으로 생각할 수 있습니다.
- 타입은 단지 집합에 포함되는 값이고 특정 값은 많은 집합에 포함될 수 있습니다.
- 따라서 타입스크립트에서는 특정 값이 string 또는 number 타입을 동시에 가질 수 있습니다.

```ts
type stringOrNumber = string | number;
```

- 이처럼 집합으로 나타낼 수 있는 타입스크립트의 타입 시스템을 지탱하고 있는 개념이 구조적 서브타이핑 입니다.
- 구조적 서브타이핑이란 객체가 가지고 있는 속성(property)을 바탕으로 타입을 구분하는것 입니다.
- 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여기게 됩니다.
- 타입스크립트의 서브타이밍, 즉 타입의 상속 역시 구조적 타이핑을 기반으로 하고 있습니다.

### 자바스크립트를 닮은 타입스크립트

- 타입스크립트의 타입 시스템은 구조적 서브타이핑을 사용하고 있으며, 이것은 명목적 타이핑과는 대조적인 타이핑 방식입니다.
- 명목적 타이핑은 타입의 구조가 아닌 타입의 이름만을 가지고 구별하는 것으로 C++, 자바 등에서 사용합니다.
  - 명목적 타이핑에서는 두 변수가 같은 이름의 데이터 타입으로 선언된 경우에만 서로 호환됩니다.
  - 명목적 타이핑을 채택한 언어에서는 이름으로 타입을 구분하기 때문에 구조가 같더라도 이름이 다르다면 다른 타입으로 취급합니다.
  - 명목적 타이핑은 타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전합니다.
    - 개발자가 의도한 타입이 아니라면 변수에 타입을 명시하는 과정에서 에러를 내뱉기 때문입니다.
    - 즉, 객체의 속성을 다른 객체의 속성과 호환되지 않도록 하여 안정성을 추구합니다.
- 타입스크립트가 구조적 타이핑을 채택한 이유는 타입스크립트가 자바스크립트를 모델링한 언어이기 때문입니다.
  - 자바스크립트는 본질적으로 덕 타이핑(duck typing)을 기반으로 합니다.
  - 덕 타이핑은 어떤 함수의 매개변숫값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는데 신경쓰지 않고 사용한다는 개념입니다.
    > [덕 타이핑은 그냥 지나치기에는 너무 재밋는 용어입니다.](https://velog.io/@thms200/Typescript-Duck-Typing-%EB%8D%95%ED%83%80%EC%9D%B4%ED%95%91)
    > 컴퓨터 프로그래밍 분야에서 덕 타이핑(duck typing)은 동적 타이핑의 한 종류로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말한다.
    > 클래스 상속이나 인터페이스 구현으로 타입을 구분하는 대신, 덕 타이핑은 객체가 어떤 타입에 걸맞은 변수와 메소드를 지니면 객체를 해당 타입에 속하는 것으로 간주한다.
    > 만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.
- 덕 타이핑과 구조적 타이핑의 차이는 타입을 검사하는 시점에 있습니다.
  - 덕 타이핑은 런타임에 타입을 검사합니다. 구조적 타이핑은 컴파일 타임에 타입체커가 타입을 검사합니다.
- 덕 타이핑과 구조적 타이핑 모두 객체 변수, 메서드 같은 필드를 기반으로 타입을 검사한다는 점에서는 동일하지만, 타입을 검사하는 시점이 다릅니다.

### 구조적 타이핑의 결과

- 타입스크립트의 구조적 타이핑의 특징 때문에 예기치 못한 결과가 나올 때도 있습니다.

```ts
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const axis of Object.keys(c)) {
    // 🚨 Element implicitly has an 'any' type
    // because expression of type 'string' can't be used to index type 'Cube'.
    // 🚨 No index signature with a parameter of type 'string'
    // was found on type 'Cube'
    const length = c[axis];

    total += length;
  }
}

// c에 들어올 객체는 Cube type의 속성 이외에도 다른 속성을 가질 수 있는 상황이 존재한다.
const namedCube = {
  width: 6,
  height: 5,
  depth: 4,
  name: "SweetCube", // string 타입의 추가 속성이 정의되었다
};

addLines(namedCube); // ✅ OK
```

- 타입스크립트는 `c[axis]`가 어떤 속성을 지닐지 알 수 없으며 `c[axis]` 타입을 number라고 확정할 수 없어서 에러를 발생시킵니다.
- 타입스크립트의 구조적 타이핑의 특징으로 Cube 타입 값이 들어갈 곳에 name같은 추가 속성을 가진 객체도 할당할 수 있기 때문에 발생하는 문제입니다.
- 이러한 한계를 극복하고자 타입스크립트에 명목적 타이핑 언어의 특징을 가미한 식별할 수 있는 유니온 같은 방법이 생겨났습니다.

### 타입스크립트의 점진적 타입 확인

- 타입스크립트는 점진적으로 타입을 확인하는 언어입니다.
- 점진적 타입 검사란 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식입니다.
- 타입을 지정한 변수와 표현식은 정적으로 타입을 검사하지만 타입 선언이 생략되면 동적으로 검사를 수행합니다.
- 타입 선언을 생략하면 암시적 타입 변환이 일어납니다.

```ts
function add(x, y) {
  return x + y;
}

// 위 코드는 아래와 같이 암시적 타입 변환이 일어난다.
function add(x: any, y: any): any;
```

- add() 함수의 매개변수 x와 y에 타입을 선언하지 않았지만 타입스크립트 컴파일러는 x, y가 잘못된 것이라고 여기지 않고, 함수의 인자와 함수의 반환값을 모두 any 타입으로 추론하게 됩니다.
- 이처럼 타입스크립트에서는 필요에 따라 타입을 생략할 수도 있고 타입을 점진적으로 추가할 수도 있습니다.
- 타입스크립트에서 프로그램을 컴파일하는 데 반드시 모든 타입을 알아야 하는 것은 아닙니다. 그러나 타입스트립트의 퍼포먼스는 컴파일타임에 프로그램의 모든 타입을 알고 있을 때 최상의 결과를 보여줍니다.
- 이러한 특징으로 인하여 타입스크립트의 타입 시스템은 정적 타입의 정확성을 100% 보장해주지 않습니다.
  - 모든 변수와 표현식의 타입을 컴파일타임에 검사하지 않아도 되기 때문에 타입이 올바르게 정해지지 않으면 런타임에서 에러가 발생하기도 하빈다.

### 값 vs 타입

- 값(value)은 프로그램이 처리하기 위해 메모리에 저장하는 모든 데이터입니다.
  - 다르게 이야기해보면 프로그램에서 조작하고 다룰 수 있는 어떤 포현이며 다양한 형태의 데이터를 포함하고 있습니다.
  - 수학적 개념에서 값으로 여기는 1, 2, 3과 같은 데이터는 물론이 1+2 같은 식이 반환하는 결괏값 3도 값에 해당합니다.
- 프로그래밍 관점에서는 문자열, 숫자, 변수, 매개변수 등이 값에 해당합니다.
  - 객체 역시 값입니다. 그리고 자바스크립트에서는 함수도 값입니다. 모든것이 객체인 언어답게 자바스크립트 함수는 런타임에 객체로 변환됩니다.
  ```ts
  // 함수
  const goWork = function (developer) {
    console.log(`tired ${developer}`);
  };
  ```
- 타입스크립트를 사용하게 되면 타입이라는 개념이 등장하게 됩니다.
  - 타입스크립트는 변수, 매개변수, 객체 속성 등에 `: type` 형태로 타입을 명시해줍니다.
  - 또는 `type`이나 `interface`키워드로 커스텀 타입을 정의할 수도 있습니다.
  - 값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있는데, 이는 타입스크립트가 슈퍼셋 언어로 type으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문에 갑 공간과 타입 공간이 서로 충돌하지 않는것 입니다.
- 타입스크립트에서는 타입과 값이 혼용되는 것 말고도 값과 타입 공간에 동시에 존재하는 심볼도 있습니다.

  - 대표적으로 `class`와 `enum`입니다.
    자바스크립트의 `class`는 객체 인스턴트를 더욱 쉽게 생성하기 위한 문법적 슈가인 반면, 타입스크립트에서 클래스는 값과 타입 공간 모두에 포함될 수 있습니다.

    ```ts
    class Developer {
      name: string;

      domain: string;

      constructor(name: string, domain: string) {
        this.name = name;
        this.domain = domain;
      }
    }

    const me: Developer = new Developer("zig", "frontend");
    ```

    - 변수명 `me` 뒤에 등장하는 `: Developer`에서 `Developer`는 타입에 해당하지만 `new` 키워드 뒤의 `Developer`는 클래스의 생성자 함수인 값으로 동작합니다.
    - 타입스크립트에서 클래스는 타입 애너테이션으로 사용할 수 있지만, 런타임에서 객체로 변환되어 자바스크립트의 값으로 사용되는 특징을 가지고 있습니다.

  - 클래스와 마찬가지로 타입스크립트 문법인 enum 역시 런타임에 객체로 변환되는 값 입니다.
    - enum은 런타임에 실제 객체로 존재하며, 함수로 표현할 수도 있습니다.
  - enum 또한 클래스처럼 타입 공간에서 타입을 제한하는 역할을 하지만 자바스크립트 런타임에서 실제 값으로도 사용될 수 있습니다.

  ```ts
  enum WeekDays {
    MON = "Mon",
    TUES = "Tues",
    WEDNES = "Wednes",
    THURS = "Thurs",
    FRI = "Fri",
  }
  // ‘MON’ | ‘TUES’ | ‘WEDNES’ | ‘THURS’ | ‘FRI’
  type WeekDaysKey = keyof typeof WeekDays;

  function printDay(key: WeekDaysKey, message: string) {
    const day = WeekDays[key];
    if (day <= WeekDays.WEDNES) {
      console.log(`It’s still ${day}day, ${message}`);
    }
  }

  printDay("TUES", "wanna go home");
  ```

  - 위 예제 코드에서는 enum이 타입으로 사용됩니다.
  - enum에 `keyof typeof`연산자를 사용해서 `type WeekDaysKey`를 만들어, `printDay()` 함수의 key 인자에 넘겨줄 수 있는 값의 타입을 제한하고 있습니다.

  - 또한 enum이 값 공간에서 사용되는 경우도 존재합니다

  ```ts
  // enum이 값 공간에서 사용된 경우
  enum MyColors {
    BLUE = "#0000FF",
    YELLOW = "#FFFF00",
    MINT = "#2AC1BC",
  }

  function whatMintColor(palette: { MINT: string }) {
    return palette.MINT;
  }

  whatMintColor(MyColors); // ✅
  ```

  - 위 예제 코드에서 `MyColors` enum은 마치 일반적인 객체처럼 동작합니다.

- 타입스크립트에서 어떠한 심볼이 값으로 사용된다는 것은 컴파일러를 사용해서 타입스크립트 파일을 자바스크립트 파일로 변환해도 여전히 자바스크립트 파일에 해당 정보가 남아있음을 의미합니다.
- 반면, 타입으로만 사용되는 요소는 컴파일 아후에 자바스크립트 파일에서 해당 정보가 사라집니다.

#### enum 관련 토의를 시작해볼까요?

- ["enum" vs "as const"](https://github.com/toss/frontend-fundamentals/discussions/6)

최근 tossFundamentals를 살펴보면서 재밋는 글을 읽은적이 있어요. `enum`과 `as const`에 관한 사례들을 이야기하는 디스커션 이었는데, 저는 트리쉐이킹이 지원되지 않는 `enum`방식에 많이 부정적이고, 배열의 순회나 순서보장이 필요하지 않은 상황이라면 지양해야 한다고만 생각하고 있었습니다.

하지만 해당 디스커션 내용을 살펴보면

- `enum`타입의 경우 tsc 단계에서 IIFE로 변환되어 tree-shaking될 수 없는 단점이 존재하지만 `const enum`의 경우 inlining을 지원하기 때문에 (0에 가까운)성능 이득을 가져올 수 있는 가능성 또는 unused dependency에 대한 고리를 끊을 수 있는 장점이 존재하고, `as const`는 임의의 중복될 수 있는 값일 경우 발생할 수 있는 기능성 차원의 시점에서 본다면 좋은 방법이 아닌것 같다라는 견해도 존재하고
- 타입스크립트를 사용할 때 `namespace` 혹은 `enum`과 같이 자바스크립트에 없는 문법을 사용하는것을 꺼리는 의견도 존재합니다.
  - 타입스크립트 생태계의 움직임을 보았을때 추후 `enum`과 같은 문법을 사용하면 생태계의 움직임과 함께 가지 못할 가능성이 제시되는 내용이에요.
- 책에 구성되어있는 우형 팀에서도 `enum`에 대한 내용이 존재합니다
  - `const enum`을 사용하면 해결할 수 있으며 `enum`을 사용한다고 해서 번들 사이즈가 서비스에 영향을 미칠정도는 아니니 크게 고민하지 않는다.
  - 타입을 선언하는 용도로 `enum`이 필요한가? 타입을 위한 문법 보다는 개발을 위한 문법 같다.
- 개인적인 견해로는 `enum`을 선호하지않습니다. 사용해도 트리쉐이킹이 되지 않는 부분으로 인해 번들 사이즈에 영향을 줄 정도는 아니라고 생각하지만, 이터러블한 값을 순회하는 용도가 아니라면 최대한 사용을 지양할것 같습니다.

글을 보고계신분이 있으시다면 enum사용에 대해서 생각하시는 내용이 있으실까요?

### 타입을 확인하는 방법

- 타입스크립트에서는 `typeof`, `instanceof`그리고 타입 단언을 사용해서 타입을 확인할 수 있습니다.
- `typeof`는 연산하기 이전에 피연산자의 데이터 타입을 나타내는 문자열을 반환합니다.
  - `typeof` 연산자가 반환하는 값은 자바스크립트의 7가지 기본 데이터 타입과 함수, 호스트객체 그리고 object 객체가 될 수 있습니다.
  - 타입스크립트에는 값 공간과 타입 공간이 별도로 존재합니다. `typeof`연산자도 값에서 쓰일 때와 타입에서 쓰일 때 역할이 다릅니다.
  - 값에서 사용된 `typeof`는 자바스크립트 런타임의 `typeof` 연산자가 됩니다.
  ```ts
  const v1 = typeof person; // 값은 ‘object’
  const v2 = typeof email; // 값은 ‘function’
  ```
  - 반면 타입에서 사용된 `typeof`는 값을 읽고 타입스크립트 타입을 반환합니다.
  ```ts
  type T1 = typeof person; // 타입은 Person
  type T2 = typeof email; // 타입은 (options: { person: Person; subject: string; body:string; }) = > void
  ```
- 자바스크립트에서 `instanceof`연산자를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있스빈다.
  - `typeof` 연산자처럼 `instanceof`연산자의 필터링으로 타입이 보장된 상태에서 안전하게 값의 타입을 정제하여 사용할 수 있습니다.
- 타입스크립트에서는 `as`키워드를 사용하여 타입을 강제하는 타입 단언을 사용할 수도 있습니다.
  - 타입 단언은 개발자가 해당 값의 타입을 더 잘 파악할 수 있을 때 사용되며 강제 형 변환과 유사한 기능을 제공합니다.

## 02.3 원시 타입

- 자바스크립트의 원시 값(메모리 공간에 존재하는)은 타입스크립으에서 원시 타입으로 존재합니다.
  > 원시 값과 원시 래퍼 객체
  > 자바스크립트의 내장 타입은 파스칼 표기법으로 표기합니다.
  > 반면 타입스크립트에서는 이에 대응하는 타입을 소문자로 표기합니다.
  > 자바스크립트는 컴파일 시점에 타입스크립트의 타입 시스템이 적용되지 않으므로 타입스크립트와 구별하기 위해 소문자로 표기하지 않았습니다.
  > 타입을 파스칼 표기법으로 표기하면 자바스크립트에서는 이것을 원시 래퍼 객체라고 부릅니다. null과 undefined를 제외한 모든 원시 값은 해당 원시 값을 래핑한 객체를 가집니다.
  > 윈시 래퍼 객체는 이름에서 알 수 있듯이 원시 값이 아닌 객체라는 점에 주의하여야 합니다.
  > 따라서 타입스크립트에서는 내장 원시 타입에 해당하는 타입을 파스칼로 표기하지 않도록 주의하여야 합니다.
  > 타입스크립트에도 원시 래퍼 객체가 존재하는데 이것은 고유한 타입으로 분류되기 대문에 둘은 엄연히 다른 개념입니다.

### boolean

```ts
const isEmpty: boolean = true;
const isLoading: boolean = false;

// errorAction.type과 ERROR_TEXT가 같은지 비교한 결괏값을 boolean 타입으로 반환하는 함수
function isTextError(errorCode: ErrorCodeType): boolean {
  const errorAction = getErrorAction(errorCode);
  if (errorAction) {
    return errorAction.type === ERROR_TEXT;
  }
  return false;
}
```

- 자바스크립트에는 `boolean` 원시 값은 아니지만 형 변환을 통해 true / false 로 취급되는 Truthy / Falsy 값이 존재합니다.
- 앞서 이야기 했듯이 이 값은 `boolean` 원시 값이 아니므로 타입스크립트에서도 `boolean` 타입에 해당하지 않습니다.

### undefined

- 초기화되어 있지 않거나 존재하지 않음을 나타냄

### null

```ts
type Person1 = {
  name: string;
  job?: string;
};

type Person2 = {
  name: string;
  job: string | null;
};
```

- `Person1`은 job이라는 속성이 있을 수도 또는 없을 수도 있음을 나타낸다.
- `Person2`는 job이라는 속성을 사람마다 갖고있지만 비어있을 수도 있다는 것을 의미한다.
- 따라서 명시적인 null 값을 할당해 무직인 상태를 표현하고 있다.
  > 옵셔널은 속성 자체가 있을수도 없을수도 있는거고 null 표현은 속성은 존재하지만 값이 있을수도 없을수도 있는거군요

### number

### bigInt

### string

### symbol

- ES1025에서 도입된 데이터 타입으로 Symbol() 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값을 생성할 수 있습니다.
- 타입스크립트에는 symbol 타입과 const 선언에서만 사용할 수 있는 unique symbol 타입이라는 symbol의 하위 타입도 존재합니다.

## 02.4 객체 타입

- 앞에서 언급한 7가지 원시 타입에 속하지 않는 값은 모두 객체 타입으로 분류할 수 있습니다.
- 타입스크립트에서는 다양한 형태를 가지는 객체마다 개별적으로 타입을 지정할 수 있습니다.
  - 예를 들어 배열 또는 클래스를 타입으로 지정할 수 있으며 매우 복잡한 구조를 가진 객체도 타입으로 만들어 관리할 수 있습니다.

### object

- 자바스크립트의 객체의 정의에 맞게 이에 대응하는 타입스크립트 타입 시스템은 object 타입입니다.
- object 타입은 가급적 사용하지 말도록 권장되는데 나중에 다룰 any 타입과 유사하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의마가 크게 퇴색되기 떄문입니다.

### `{}`

- 중괄호는 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용합니다.
- 타입스트립트에서 객체를 타이핑할 때도 중괄호를 사용할 수 있는데, 중괄호 안에서 객체 속성 타입을 지정해주는 식으로 사용합니다.
- 중괄호를 사용하여 빈 객체 타입을 선언할 수도 있지만, 유틸리티 타입으로 `Record<string, never>` 처럼 사용하는것이 바람직합니다. (5장에서 출현 예정)

### array

- 타입스크립트는 자바스크립트 객체를 세분화해서 타입을 지정할 수 있는 타입 시스템을 갖고 있습니다.
- 자바스크립트에서는 흔히 사용하는 객체 자료구조 외에도 배열, 함수, 정규식 등이 객체 범주에 속합니다.
- 타입스크립트에서는 이런 각각의 객체에 타입을 지정할 수 있습니다.
- 자바스크립트 배열 자료구조는 원소를 자유롭게 추가하고 제거할 수 있으며 타입 제한 없이 다양한 값을 다룹니다.
  - 즉 하나의 배열 안에 숫자, 문자열과 같은 서로 다른 값이 혼재될 수 있습니다.
  - 하지만 이런 사용법은 타입스크립트가 추구하는 정적 타이핑 방향과 맞지 않습니다.
- 타입스크립트에서는 배열은 array 라는 별도 타입으로 다룹니다.
- 타입스크립트 배열 타입은 하나의 타입 값만 가질 수 있다는 점에서 자바스크립트 배열보다 조금 더 엄격합니다.
- 하지만 자바스크립트와 마찬가지로 원소 개수는 타입에 영향을 주지 않습니다.
- 타입스크립트에서 배열 타입을 선언하는 방식은 `Array`키워드로 선언하거나 대괄호([])를 사용해서 선언하는 방법이 있습니다.

### type과 interface 키워드

- 앞에서 언급한 타입스크립트 object 타입은 실무에서는 잘 사용하지 않습니다.
- 흔히 객체를 타이핑하기 위해 자주 사용하는 키워드로 type과 interface가 있습니다.

#### type과 interface에 대하여 토의를.... 시작해볼까요....?

- 우형이야기를 읽어보면서 정리를 조금 해보았어요

1. `type`과 `interface`를 둘 다 쓸 수 있는 상황이라면?

   - 만약 컨벤션으로 정한다면 공식 문서에 쓰인 내용을 바탕으로 전역적으로 사용할 때는 `interface`를. 작은 범위 내에서 한정적으로 사용한다면 `type`을 사용해도 되지 않을까..?
   - `type`은 어떤 값에 대한 정의같이 정적으로 결정되어 있는 것. `interface`는 확장될 수 있는 basis를 정리하거나 어떤 object 구성을 설명하는 요소라고 생각.
   - 선언 병합이 필요할 때는 `interface`를 사용. computed value를 사용해야 한다면 `type`정의를 사용.
   - 디버깅시 IDE에서 `interface`는 인터페이스 이름만 노출되고, `type`은 리터럴한 값이 직접 노출되므로 `type`을 사용하여 더 쉽게 타입 추론이 가능하므로 `type`을 선호.

2. 팀 내에서 `type`과 `interface`만을 써야하는 상황이 있었는지?
   - 객체 지향적으로 코드를 짤 때, 특히 상속(extends, implements)하는 경우에 `interface`를 사용.
   - 유니온 타입이나 교차 타입 등 `type`정의에서만 사용할 수 있는 기능을 활용할 때 `type`을 활용. `interface`는 같은 속성을 공유하는 기준 인터페이스를 정의하고 확장할 때 사용.

- 저희 팀에서는 타입에 대한 네이밍 컨벤션이 존재해서 이부분만을 고려해서 T- prefix를 부착하는 형태로 type을 주로 사용하고 있습니다. 이런 사용 사례들을 보면 아직은 프로젝트에서 해당 부분에 대해 많은 고민을 하고 있는것 같지 않은거같아요.

### function

- 자바스크립트에서는 함수도 일종의 객체로 간주하지만 `typeof` 연산자로 함수 타입을 출력해보면 자바스크립트는 함수를 function이라는 별도 타입으로 분류한다는 것을 확인할 수 있습니다.
- 마찬가지로 타입스크립트에서도 함수를 별도 함수 타입으로 지정할 수 있습니다.
  - 다만 객체 타이핑과는 달리 주의할 점이 존재합니다.
    - 첫째는 function이라는 키워드 자체를 타입으로 사용하지 않습니다,
    - 둘째는 함수는 매개변수 목록을 받을 수 있는데 타입스크립트에서는 매개변수도 별도 타입으로 지정해야 합니다.
