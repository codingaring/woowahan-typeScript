## 01.1 웹 개발의 역사

### 자바스크립트 표준 ECMAcript의 탄생

- 초기 브라우저 생태계는 DOM 구조가 서로 상이하여 브라우저마다 웹페이지가 다르게 동작하거나 제대로 도작하지 않는 크로스 브라우징 이슈가 발생했다.
- 크로스 브라우징 이슈로 인해 개발자은 기능을 추가하기 위해서는 두 개의 스크립트를 따로 개발해야 하는 어려움을 겪어야만 했다.
- 또한 초기 자바스크립트는 브라우저를 고려해서 작성한 것이 아니었고, 단순히 새로운 기능이 추가되는 형태로 발전하고 있었다.
- 결국 브라우저가 자바스크립트의 변화를 따라가지 못하는 문제가 발생했다.
- 자바스크립트에 어떠한 기능이 추가된다면 런타임 환경인 브라우저도 이 기능을 지원할 수 있어야 한다.
  - flat메서드가 지원되지 않는 런타임 환경이 존재한다는걸 알고계십니까?
  - 자바스크립트가 새로운 기능을 지원하며 발전하더라도 사용자가 예전 버젼의 브라우저 혹은 런타임 환경을 사용한다면 새로운 기능은 무용지물이 된다.
- 이러한 문제를 해결하기 위해 자바스크립트에 **폴리필 Polyfill**과 **트랜스파일 Transpile**같은 개념이 등장하기도 했다.
- 결국 모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트의 필요성이 제기됨.
- Ecma 인터네셔널을 통하여 ECMAScript 라는 이름으로 자바스크립트 표준화가 공식화되었다.
  - 자바스크립트의 표준화로 인하여 정적 웹사이트에서 동적 웹앱으로의 전환이 가속화되는 계기중 하나가 되었다.

> ##### 아하모먼트 😮
>
> ##### 폴리필(polyfill)과 트랜스파일(transpile)
>
> 폴리필은 브라우저가 지원하지 않는 코드를 브라우저에서 사용할 수 있도록 변환한 코드 조각이나 플러그인을 말한다. 트랜스파일은 최신 버젼의 코드를 구형 버젼의 코드로 변환하는 과정을 말한다.
> 두 개념 다 최신 기능을 구버전의 실행 환경에서 동작할 수 있게 바꿔주는 역할를 한다.

#### 폴리필 예시

- Array.prototype.flat 폴리필

  - `flat`메서드는 ES2019에서 도입된 메서드로 구형 브라우저에서는 지원이 안되는 경우가 존재합니다.
  - 구현 예시

    ```ts
    if (!Array.prototype.flat) {
      Array.prototype.flat = function (depth = 1) {
        const flatten = (arr, currentDepth) => {
          return currentDepth > 0
            ? arr.reduce((acc, val) => {
                if (Array.isArray(val)) {
                  return acc.concat(flatten(val, currentDepth - 1));
                }
                return acc.concat(val);
              }, [])
            : arr.slice();
        };

        return flatten(this, depth);
      };
    }

    // 사용 예시
    const nestedArray = [1, [2, 3], [4, [5, 6]]];
    console.log(nestedArray.flat()); // [1, 2, 3, 4, [5, 6]]
    console.log(nestedArray.flat(2)); // [1, 2, 3, 4, 5, 6]
    ```

- 폴리필 라이브러리도 존재합니다.
  - core-js
  - polyfill.io
    등등

#### 트랜스파일러 예시

- Babel: 대표적인 JavaScript 트랜스파일러
  - ES6+ => ES5 변환
  - JSX → JavaScript 변환
  - TypeScript → JavaScript 변환
    등의 역할을 수행함

##### 모듈시스템이 호환되지 않는 환경도 존재한다.

- 구형 Node.js 버전
- 많은 npm 패키지가 CJS로 이루어져 있음
- 일부 빌드 도구에서는 ESM에 대한 지원 부족
- React Native: Metro 번들러의 ESM 지원 한계

ESM으로 작성된 모듈이 있다면 버전 혹은 번들러에 맞추기 위해 트랜스파일링 작업이 요구됨

### 웹사이트에서 웹 애플리케이션으로의 전환

#### 웹사이트

- 웹사이트란 수집된 데이터 밎 정보를 특정 페이지에 표시하기 위한 정적인 웹이다.
- 단방향으로 정보를 제공하기 때문에 사용자와 상호 작용하지 않으며, HTML에 링크가 연결된 웹페이지 모음으로 콘텐츠가 동적으로 업데이트 되지 않는다.

#### 웹 애플리케이션

- 웹 애플리케이션은 사용자와 상호작용하는 쌍방향 소틍의 웹을 말한다.
- 검색, 댓글, 채팅, 좋아요 기능 등 웹 페이지 내부에 수많은 애플리케이션이 동작하고 있기 때문

### 개발 생태계의 발전

- 웹 서비스의 규모가 커짐에 따라 다루어야 하는 데이터, 화면, 디바이스, UX/UI등이 매우 다양해져왔고, 이러한 상황과 맞물려 `컴포넌트 베이스 개발(CBD)` 방법론이 등장했다.
  - CBD는 서비스에서 다루는 데이터를 구분하고 그에 맞는 UI를 표현할 수 있게 컴포넌트 단위로 개발하는 접근 방식이다.
  - 요즘은 작은 컴포넌트를 조합해서 좀 더 큰 컴포넌트를 만들어가는 방식이 주류가 되었다.

> ##### 아하모먼트
>
> ##### 컴포넌트 베이스 개발 Component Based Development, CBD
>
> 재사용할 수 있는 컴포넌트를 개발 또는 조합해서 하나의 애플리케이션을 만드는 개발 방법론
>
> ##### 리액트에서 컴포넌트란?
>
> 컴포넌트는 UI를 구성하는 독립적이고 재사용 가능한 코드 조각으로 설명 가능하다.
> 특정 기능이나 UI 요소를 캡슐화하며 클래스형과 함수형으로 크게 구분이 가능하다.
> 주요 장점은 재사용성과 유지보수성이며, props를 통해 부모로부터 데이터를 전달받을 수 있어 동적인 UI를 구현 가능하다.

- 컴포넌트는 모듈과 유사하게 하나의 독립된 기능을 재사용하기 위한 코드 묶음이다.
  - 다만 모듈과는 다르게 런타임 환경에서 독립적으로 배포, 실행될 수 있는 단위이다.

## 01.2 자바스크립트의 한계

### 동적 타입 언어

- 자바스크립트의 특징 중 하나는 동적 타입 언어라는 것이다.
  - 변수에 타입을 명시적으로 지정하지 않고 코드가 실행되는 런타임에 변수의 값이 할당될 때 해당 값의 타입에 따라 변수 타입이 결정된다는 것을 의미한다.

> 타입스크립트를 사용한다는건 동적타입언어인 JS를 빌드타임을 통한 정적분석으로 JS의 단점을 해결하는건가

### 동적 타이핑 시스템의 한계

```js
// 이 함수는 숫자 a, b의 합을 반환한다.
const sumNumber = (a, b) => {
  return a + b;
};

sumNumber(100); // NaN
sumNumber("a", "b"); // ab
```

코드에 적힌 주석과 함수 이름은 두 수의 합을 구하기 위한 함수로 명시하고 있다.
하지만 해당 함수는 하나의 숫자를 전달했을 때도 오류없이 NaN 값을 반환하거나, 숫자가 아닌 문자열의 합을 구하는 데도 사용될 수 있다.
자바스크립트 엔진은 이를 문제 없이 실행한다.
동적 타입 언어라는 특성 때문에 함수를 호출할 때 사용하는 인수의 값에 따라 a와 b의 타입이 결정된다.
**즉 개발자의 의도와 다르게 동작할 수 있다.**

- 예시와 해설과 같이 자바스크립트 엔진에서 주석, 함수 이름, 개발자 의도 같은 것은 고려 대상이 아니다.
- 따라서 예시 코드는 기계 입장에서는 정상적이지만 사람 입장에서는 정상적이지 않은 코드이다.

### 한계 극복을 위한 해결 방안

- 동적 타이핑 시스템의 한계는 당연하게도 많은 어려움을 야기했다.
- 자바스크립트의 인터페이스를 정의할 필요성을 느끼게 되었고 jsDoc, propTypes, 다트 같은 해결 방안이 등장했다.

#### JSDoc

- JSDoc는 모듈, 네임스페이스, 클래스, 메서드, 매개변수 등에 대한 API 문서 생성 도구다.
- 주석에 @ts-check을 추가하면 타입 및 에러 확인이 가능하며 자바스크립트 소스코드에 타입 힌드를 제공하는 HTML 문서를 생성할 수 있다.
  > 요즘 실무에서 JSDoc 매우 유용하게 잘 사용하고 있습니다.
  >
  > ```ts
  > /**
  > * 결제 상품 정보 생성
  > * @description TProduct를 기반으로 결제용 PaymentItem을 생성합니다.
  > - @typedef {TProduct} TProduct
  > - @property {string} productId 상품 아이디
  > - @property {string} productName 상품명
  > - @property {string} internalName 관리용 상품명
  > - @property {number} quantity 결제 수량
  > - @property {string} unit 단위
  > - @property {number} originPrice 정가
  > - @property {number} salePrice 판매가
  > - @property {number} discountPrice 할인 금액
  > - @property {number} rewardPoint 리워드 포인트
  > -
  > - @returns {TPaymentItemSchema} PaymentItemDocument
  > */
  > ```

#### propTypes

```js
import PropTypes from "prop-types";

class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

Greeting.propTypes = {
  name: PropTypes.string,
};
```

- 대충 이런 내용입니다
- [관련 링크](https://ko.legacy.reactjs.org/docs/typechecking-with-proptypes.html)

#### 다트

- Dart는 구글이 자바스크립트를 대체하기 위해 제시한 새로운 언어입니다.
- 이미 자바스크립트가 자리매김한 상황에서 새로운 언어의 등장으로 인한 혼선을 불러올 수 있어 다트를 달갑지 않게 보는 시선이 강했음.

### 타입스크립트의 등장 두둥

- 시간의 지남에 따라 MS라는 스타트업에서 자바스크립트의 슈퍼셋 언어닌 타입스크립트를 공개했다.
- 다트와 달리 자바스크립트 코드를 사용할 수 있었고, 자바스크립트의 단점을 극복할 수 있었기 때문에 많은 환영을 받았다.

#### 안정성 보장

- 타입스크립트는 정적 타이핑을 제공한다.
- 컴파일 단계에서 타입 검사를 해주기 때문에 자바스크립트를 사용했을 때 빈번하게 발생하는 타입 에러를 줄일 수 있고, 런타임 에러를 사전에 방지할 수 있어 안정성이 크게 높아진다.

#### 개발 생산성 향상

- VSCode 등의 IDE에서 type 자동 완성 기능을 제공한다.
- 이 기능으로 변수와 함수 타입을 추론할 수 있고, 리액트를 사용할 때 어떤 prop을 넘겨야 하는지 사용부에서 바로 볼 수 있기 때문에 개발 생산성이 크게 향상된다.

#### 협업에 유리

- 타입스크립트를 사용하면 복잡한 애플리케이션 개발 협업에 유리하다.
- `interface`, `Generic` 등을 지원하는데 인터페이스가 기술되면 코드를 더 쉽게 이해할 수 있게 도와준다.
- 또한 자동 완성 기능이나 기술된 인터페이스로 코드를 쉽게 파악할 수 있다.

> ##### 타입스크립트 인터페이스 interface
>
> 타입스크립트 인터페이스는 객체 구조를 정의하는 역할을 한다.
> 다시 말해 특정 객체가 가져야 하는 속성과 메서드의 집합을 인터페이스로 정의해서 객체가 그 구조를 따르게 한다.

#### 자바스크립트에 점진적으로 적용 가능

- 타입스크립트는 자바스크립트의 슈퍼셋 언어이기 때문에 일괄 전환이 아닌 점진적 도입이 가능하다.
- 일부 프로젝트, 일부 기능부터 점진적으로 도입해볼 수 있다.
