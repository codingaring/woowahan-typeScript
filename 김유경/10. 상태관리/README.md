# 상태 관리

## 1. 상태 (state)

상태란 무엇인가?

- 리액트 애플리케이션에서의 상태는 렌더링에 영향을 줄 수 있는 동적인 데이터 값을 말한다.
  > 렌더링 결과에 영향을 주는 정보를 담은 순수 자바스크립트 객체

상태의 분류

- 지역 상태, 전역 상태, 서버 상태

### 지역 상태 (Local State)

컴포넌트 내부에서 사용되는 상태로, 체크 박스의 체크 여부나 폼의 입력값 등

> useState 훅, useReducer 사용

### 전역 상태 (Global State)

앱 전체에서 공유하는 상태를 의미

- 여러 개의 컴포넌트가 전역 상태를 사용할 수 있으며, 상태가 변경되면 컴포넌트들도 업데이트 된다.
- prop drilling 문제를 피하고자 지역 상태를 해당 컴포넌트들 사이의 전역 상태로 공유할 수도 있다.
  > contextAPI

### 서버 상태 (Server State)

사용자 정보, 글 목록 등 외부 서버에 저장해야하는 상태들을 의미.

- UI 상태와 결합하여 관리하게 되며 로딩 여부나 에러 상태 등을 포함한다.
- 서버 상태는 지역 상태 혹은 전역 상태와 동일한 방법으로 관리되며 최근에는 react-query, SWR과 같은 외부 라이브러리를 사용하여 관리하기도 한다.

## 2. 상태를 잘 관리하기 위한 가이드

상태는 애플리케이션의 복잡성을 증가시키고 동작을 예측하기 어렵게 만든다.

- 상태가 업데이트 될 때마다 리렌더링이 발생하기 떄문에 유지보수 및 성능 관점에서 상태의 개수를 최소화하는 것이 바람직하다.
- 만약 불가피하게 상태를 사용한다면 다음 2가지를 고려해야 한다.
  > 시간이 지나도 변하지 않는다면 상태가 아니다
  > 파생된 값은 상태가 아니다

### 시간이 지나도 변하지 않는다면 상태가 아니다

시간이 지나도 변하지 않는 값이라면, 객체 참조 동일성을 유지하는 방법을 고려해볼 수 있다.

- 대표적인 객체 참조 동일성을 유지하기 위한 방법은 메모이제이션이다.

```ts
const Component:React.VFC = () => {
    const store = useMemo(()=> new Store(), [])

    return (
        <StoreProvider store={store}>
            <Children>
        </StoreProvider>
    )
}
```

단순히 코드만 봤을 때는 문제가 없어 보이지만, 객체 참조 동일성을 유지하기 위해 useMemo를 사용하는 것은 권장되는 방법이 아니다.

- 리액트의 공식 문서에서는 useMemo를 통한 메모이제이션은 의미상으로 보장된 것이 아니기 때문에 오로지 성능 향상을 위한 용도로만 사용되어야 한다고 언급하고 있다.
- 또한, 리액트에서는 메모리 확보를 위해 이전 메모이제이션 데이터가 삭제될 수 있다고 한다.

=> useMemo 없이도 올바르게 동작하도록 코드를 작성하고, 나중에 성능 개선을 위해 useMemo를 추가하는 것이 적절한 접근 방식이다.

#### 원하는 대로 동작하게 만드는 방법

- useState의 초깃값만 지정하는 방법
- useRef를 사용하는 방법

1. useState의 초깃값만 지정하는 방법
   모든 렌더링 과정에서 객체 참조를 동일하게 유지할 수 있다.

- 그러나, `useState(new Store())`와 같이 사용하면 객체 인스턴스가 실제로 사용되지 않더라도 렌더링마다 생성되어 초깃값 설정에 큰 비용이 소요될 수 있다.

  > 따라서 `useState(()=> new Store())`와 같이 초깃값을 계산하는 콜백을 지정하는 방식(지연 초기화 방식)을 사용한다.

- 다만 useState를 사용하는 것은 기술적으로는 잘 동작할 수 있지만, 의미론적으로 봤을 때는 좋은 방법이 아니다.
  > 처음에는 상태를 시간이 지나면서 변화되어 렌더링에 영향을 주는 데이터로 정의했지만, 현재의 목적은 모든 렌더링 과정에서 객체의 참조를 동일하게 유지하고자 하는 것이기 때문이다.

2. useRef를 사용하는 방법

useRef()와 {current...} 객체를 직접 생성하는 방법 간의 유일한 차이는 useRef는 매번 렌더링할 때마다 동일한 ref 객체를 제공한다는 것이다.

- 리액트 공식 문서에 따르면 useRef가 동일한 객체 참조를 유지하려는 목적으로 사용하기에 가장 적합한 훅이다. useRef의 인자로 직접 new Store()를 사용하면 useState와 마찬가지로 렌더링마다 불필요한 인스턴스가 생성되므로 아래와 같이 작성해줘야 한다.

```ts
const store = useRef<Store>(null);

if (!store.current) {
  store.current = new Store();
}
```

- useRef는 기술적으로 useState({children : initialValue})[0] 과 동일하다고 할 수 있다. 그러나 상태라고 하는 것은 렌더링에 영향을 주며 변화하는 값을 의미하고 있기 때문에, 의미론적으로 객체 참조 동일성을 유지하기 위해 useState에 초깃값만 할당하는 것은 적절하지 않다.
- 가독성 등의 이유로 팀 내에서 합의된 컨벤션으로 지정된 것이 아니라면 동일한 객체 참조를 할 때는 useRef를 사용할 것을 권장한다.

### 파생된 값은 상태가 아니다.

부모로부터 전달받을 수 있는 props이거나 기존 상태에서 계산될 수 있는 값은 상태가 아니다.

- SSOT(Single Source Of Truth)는 어떠한 데이터도 단 한 줄의 출처에서 생성하고 수정해야 한다는 원칙을 의미하는 방법론이다.
- 리액트 앱에서 상태를 정의할 때도 이를 고려해야 한다.
  > 다른 값에서 파생된 값을 상태로 관리하게 되면, 기존 출처와는 다른 새로운 출처에서 관리하게 되는 것이므로 데이터의 정확성과 일관성을 보장하기 어렵다

### useState vs useReducer, 어떤 것을 사용해야 할까

useState 대신 useReducer 사용을 권장하는 경우는 크게 2가지가 있다.

- 다수의 하위 필드를 포함하고 있는 복잡한 상태 로직을 다룰 때
- 다음 상태가 이전 상태에 의존적일 때

#### 배달의 민족 리뷰 리스트를 필터링하여 보여주기 위한 쿼리를 상태로 저장해야하는 상황

- 해당 쿼리는 단순하지 않고, 검색 날짜 범위, 리뷰 점수, 키워드 등 많은 하위 필드를 가지게 된다.
- 페이지네이션을 고려하면 페이지, 사이즈 등의 필드도 추가될 수 있다.

```ts
// 날짜 범위 기준 - 오늘, 1주일, 1개월
type DateRangePreset = "TODAY" | "LAST_WEEK" | "LAST_MONTH";

type ReviewRatingString = "1" | "2" | "3" | "4" | "5";

interface ReviewFilter {
  // 리뷰 날짜 필터링
  startDate: Date;
  endDate: Date;
  dateRangePreset: Nullable<DateRangePreset>;

  // 키워드 필터링
  keywords: string[];

  // 리뷰 점수 필터링
  ratings: ReviewRatingString[];

  // ...이외 기타 필터링 옵션
}

// Review List Query State
interface State {
  filter: ReviewFilter;
  page: string;
  size: number;
}
```

- 이러한 데이터 구조를 useState로 다루면 상태를 업데이트할 때마다 잠재적인 오류 가능성이 증가한다.

  > 예를 들어 페이지값만 업데이트하고 싶어도 우선 전체 데이터를 가지고 온 다음 페이지값을 덮어쓰게 되므로 사이즈나 필터 같은 다른 필드가 수정될 수 있어 의도치 않은 오류가 발생할 수 있다.

  > 또한, '사이즈 필드를 업데이트할 때는 페이지 필드를 0으로 설정해야 한다' 같은 특정한 업데이트 규칙이 있다면 useState 만으로는 한계가 있다.

- useReducer는 '무엇을 변경할지'와 '어떻게 변경할지'를 분리하여 dispatch를 통해 어떤 작업을 할지를 액션으로 넘기고 reducer 함수 내에서 상태를 업데이트하는 방식을 정의한다.
  > 이로써 복잡한 상태 로직을 숨기고 안정성을 높일 수 있다.

```ts
// Action 정의
type Action =
  | { payload: ReviewFilter; type: "filter" }
  | { payload: number; type: "navigate" }
  | { payload: number; type: "resize" };

// Reducer 정의
const reducer: React.Reducer<State, Action> = (state, action) => {
  switch (action.type) {
    case "filter":
      return {
        filter: action.payload,
        page: 0,
        size: state.size,
      };
    case "navigate":
      return {
        filter: state.filter,
        page: action.payload,
        size: state.size,
      };
    case "resize":
      return {
        filter: state.filter,
        page: 0,
        size: action.payload,
      };
    default:
      return state;
  }
};
```

- 이외에도 boolean 상태를 토글하는 액션만 사용하는 경우에는 useState대신 useReducer를 사용하곤 한다.

```ts
import { useReducer } from "react";

// Before
const [fold, setFold] = useState(true);

const toggleFold = () => {
  setFold((prev) => !prev);
};

// After
const [fold, toggleFold] = useReducer((v) => !v, true);
```

## 3. 전역 상태 관리와 상태 관리 라이브러리

- 상태는 사용하는 곳과 최대한 가까워야 하며 사용 범위를 제한해야만 한다.

  > contextAPI + useState 또는 useReducer

  > 외부 상태 관리 라이브러리(Redux, MobX, Recoil 등)

### contextAPI

- 다른 컴포넌트들과 데이터를 쉽게 공유하기 위한 목적으로 제공되는 API이다.
- 깊은 레벨에 있는 컴포넌트 사이에 데이터를 전달하는 PropDrilling 같은 문제를 해결하기 위한 도구로 활용된다.

- UI 테마 정보나 로케일 데이터 같이 전역적으로 제공하거나 컴포넌트의 props를 하위 컴포넌트에게 계속해서 전달해야할 때 유용하게 사용할 수 있다.
- contextAPI는 엄밀하게 말해, 전역 상태를 관리하기 위한 솔루션이라기보다 여러 컴포넌트 간에 값을 공유하는 솔루션에 가깝다.
  > 그러나 useState나 useReducer 같이 지역 상태를 관리하기 위한 API와 결합하여 여러 컴포넌트 사이에서 상태를 공유하기 위한 방법으로 사용되기도 한다.

#### 주의해야 할 점

- contextAPI를 사용하여 전역 상태를 관리하는 것은 대규모 애플리케이션이나 성능이 중요한 애플리케이션에서 권장되지 않는 방법이다.
- 그 이유는 컨텍스트 프로바이더의 props로 주입된 값이나, 참조가 변경될 때마다 해당 컨텍스트를 구독하고 있는 모든 컴포넌트가 리렌더링되기 때문이다.

# 상태 관리 라이브러리

## MobX

객체 지향 프로그래밍과 반응형 프로그래밍 패러다임의 영향을 받은 라이브러리다.

#### 반응형 프로그래밍 패러다임이 뭔가 싶어서 chatGPT한테 물어봤습니다.

데이터의 변화가 곧바로 연산/결과/UI 흐름에 전파되는 방식을 핵심으로 하는 프로그래밍 패러다임

즉, “값이 변하면 → 그걸 쓰는 다른 값도 자동으로 다시 계산되고 → UI, state, side effect 등이 즉시 동기적으로 반응한다” 구조.

### 장점

- 상태 변경 로직을 단순하게 작성할 수 있음
- 복잡한 업데이트 로직을 라이브러리에 위임할 수 있음

### 단점

- 데이터가 언제, 어떻게 변하는지 추적이 어렵기 때문에 트러블슈팅에 어려움을 겪을 수 있음

## Redux

함수형 프로그래밍의 영향을 받은 라이브러리.

### 장점

- 특정 UI 프레임워크에 종속되지 않아 독립적으로 상태 관리 라이브러리를 사용할 수 있음
- 오랜 기간 사용되어 왔기 때문에 다양한 요구 사항에 대해 충분히 검증되었음
- 상태 변경 추적에 최적화되어 있어, 특정 상황에서 발생한 애플리케이션의 문제 원인 파악에 용이함

### 단점

- 단순한 상태 설정에도 많은 보일러 플레이트가 필요하고, 사용 난도가 높음

## Recoil

상태를 저장할 수 있는 Atom과 해당 상태를 변형할 수 있는 순수 함수 selector를 통해 상태를 관리하는 라이브러리다.

### 장점

- Redux에 비해 보일러플레이트가 적고 난이도가 쉬움

### 단점

- 라이브러리가 아직 experimental 상태이기 때문에 다양한 요구사항에 대한 충분한 검증이 이루지지 않았다.

## Zustand

Flux 패턴을 사용하며 많은 보일러플레이트를 가지지 않는 훅 기반의 편리한 API모듈을 제공한다.

- 클로저를 활용하여 스토어 내부 상태를 관리함으로써 특정 라이브러리에 종속되지 않는 특징이 있다.

- 상태와 상태를 변경하는 액션을 정의하고, 반환된 훅을 어느 컴포넌트에서나 임포트하는 대로 사용할 수 있다.
