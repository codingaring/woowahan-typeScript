# 1. 타입스크립트만의 독자적 타입 시스템

- 타입스크립트의 타입 시스템은 자바스크립트에서 기인되었지만, 자바스크립트 자료형에서 제시되지 않은 시스템을 가지고 있다.
- 예시) any 타입은 prototype.toString.call(...)를 사용하여 콘솔에서 타입을 추적해도 나오지 않는다.

### 타입스크립트의 타입 계층 구조

![alt text](image.png)

## 1) any

### 특징

- 자바스크립트에 존재하는 모든 값을 오류없이 받을 수 있다.
- 자바스크립트의 기본적인 사용 방식과 같다. (타입스크립트를 안쓰는 것과 같은 방식)
- 타입스크립트의 정적 타이핑의 장점은 싹 다 무시하고 동적 타이핑으로 돌아가는 것과 비슷한 결과를 가져온다.
- `any`를 회피하는 것은 정적 타입의 관점에서 봤을 때 아주 타당한 행동이다.
- 회피하기 위해 `tsconfig.json` 파일에서 `noImplicityAny`를 활성화하면 암묵적 any 타입에 대한 경고를 발생시킨다.

### 어쩔 수 없이 any를 써야하는 상황

#### 1. 개발 단계에서 임시로 값을 저장해야 할 때

- 데이터의 세부 스펙이 나오기 전

#### 2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때

- API요청 및 응답 처리
- 콜백 함수 전달
- 타입이 잘 정제되지 않아 타입 파악이 힘든 외부 라이브러리 등을 사용할 때

#### 3. 값을 예측할 수 없을 때 암묵적으로 사용

- 외부 라이브러리나 웹 API의 요청에 따라 다양한 값을 반환하는 API가 존재할 수 있다.
- 예시) `Fetch API`

  - Fetch API의 일부 메서드는 요청 이후의 응답을 특정 포맷으로 파싱하는데 이때 반환 타입이 any로 매핑되어 있다.

  ```ts
  async function load() {
    const response = await fetch("https://api.com");
    const data = await response.json(); // response.json()의 리턴 타입은 Promise<any>로 정의되어 있다.

    return data;
  }
  ```

## any를 지양해야 하는 이유

- 타입스크립트의 타입 검사를 무색하게 만들고, 잠재적으로 위험한 상황을 초래할 가능성이 커진다.
- 개발자에게 편의성과 확장성을 제공하기도 하지만 해당 값을 컨트롤하려면 파악해야할 정보도 많다.
  - 도구의 도움을 받을 수 없는 상태에서 온전히 개발자 스스로 책임을 져야 한다.
    -> 협업 시 실수할 가능성이 높아진다. = 휴먼 에러 발생의 위험성이 높아짐

## 2) unknown

> 이름처럼 무엇이 할당될 지 아직 모르는 상태의 타입을 말한다.

### 특징

- `any`와 유사하게 모든 타입의 값이 할당될 수 있다.
- 하지만, any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다.
- 타입스크립트 3.0 릴리스 때 추가됨
  - 기존 타입 시스템에서 부족한 부분을 보완하기 위해 등장했다.
-

| any                                                                                                   | unknown                                                                                                  |
| ----------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| - 어떤 타입이든 any 타입에 할당 가능 <br /> - any 타입은 어떤 타입으로도 할당 가능 (단, never은 제외) | - 어떤 타입이든 unknown 타입에 할당 가능 <br /> - unknown 타입은 any 타입 외에 다른 타입으로 할당 불가능 |

```ts
let unknownValue: unknown;

unknownValue = 100; // any 타입과 유사하게 숫자이든
unknownValue = "hello world"; // 문자열이든
unknownValue = () => console.log("this is any type"); // 함수이든 상관없이 할당이 가능하지만

let someValue1: any = unknownValue; // (O) any 타입으로 선언된 변수를 제외한 다른 변수는 모두 할당이 불가
let someValue2: number = unknownValue; // (X)
let someValue3: string = unknownValue; // (X)
```

### unknown 타입이 추가된 이유

- any를 타입을 특정 타입으로 수정해야 하는 것을 깜빡하고 누락하면 어떤 값이든 전달될 수 있기 때문에 런타임에 예상치 못한 버그가 발생할 가능성이 높아진다.
- 이러한 any 사용 상황을 보완하기 위해 등장한 unknown 타입은 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 때문에 any 타입보다 더 안전하다.

> 우형 이야기

- any는 웬만하면 지양, 하지만 라이브러리에도 있는 걸 보면 꼭 필요한 경우는 있는 것 같다. <br />
  => 과도한 타입 캐스팅을 해야할 때는 any

  - unknown은 강제 타입 캐스팅으로 타입 전환할 때 사용한다.

  ## 3) void 타입

  > 값을 반환하지 않는 함수의 리턴값을 표현

  - void는 undefined가 아니다.
  - 변수에도 사용할 수는 있지만 void로 타입이 지정된 경우 undefined, null만 할당 가능하다.
  - 하지만, tsconfig.json에서 strictNull-Checks 옵션이 설정되었거나 컴파일 시 해당 플래그 설정이 실행되는 경우에는 null 값을 할당할 수 없다.
  - 명시적으로 undefined와 null 타입 키워드를 직접 사용해서 타입을 지정하는 것이 더 바람직하다.

## 4) never 타입

- 함수와 관련하여 많이 사용되는 타입이다.
- 값을 반환할 수 없는 타입
- never 타입은 모든 타입의 하위 타입이다.
  - never 자신을 제외한 어떤 타입도 never 타입에 할당될 수 없다.
  - 심지어 any 타입도 할당될 수 없다.

### 값을 반환할 수 없는 상황

#### 1. 에러를 던지는 경우

- 런타임에 의도적으로 에러를 발생시키고 캐치할 수 있다.
- throw 키워드를 사용하면 에러를 발생시킬 수 있는데, 이는 값을 반환하는 것으로 간주하지 않는다.

#### 2. 무한히 함수가 실행되는 경우

- 함수 내에서 무한 루프를 실행하는 경우 = 함수가 종료되지 않음을 의미

```ts
function checkStatus(): never {
  while (true) {
    // ...
  }
}
```

## 5) Array 타입

> 배열 타입을 가리키는 Array 키워드는 자바스크립트에서도 Object.prototype.toString.call(...) 연산자를 사용하여 확인할 수 있다.
> typeof 로 확인했을 때는 Object로 나오는 것과 다르게 ,인스턴스까지 알려준다.

- 자바스크립트에서는 배열을 객체에 속하는 타입으로 분류한다. 즉, 자바스크립트에서는 배열을 단독으로 배열이라는 자료형에 국한하지 않는다.
- 타입스크립트에서는 Array라는 타입을 사용하기 위해서는 타입스크립트의 특수한 문법을 함께 다뤄야 한다.

### 자바스크립트의 배열

- 다른 정적 언어에서는 배열의 원소로 하나의 타입만 사용하도록 명시하는 것과 다르게, 자바스크립트는 타입에 상관없이 원소를 삽입하고 관리할 수 있다.
- 자바스크립트에서 배열 타입을 선언하기 위해 제네릭을 이용한다.

```ts
// 숫자에 해당하는 원소만 허용한다.
const array: number[] = [1, 2, 3];
const array2: Array<number> = [1, 2, 3];
```
